

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Glance Graph</title>

    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>

<!-- load the d3.js library -->	
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>


<!--<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>-->
<button class="btn disk" onmouseover= "highlight('disk')" onmouseout="highlight(null)">Disks</button>
<button class="btn nic" onmouseover= "highlight('nic')" onmouseout="highlight(null)">NICs</button>
<button class="btn cpu" onmouseover= "highlight('cpu')" onmouseout="highlight(null)">CPUs</button>
<button class="btn gpu" onmouseover= "highlight('gpu')" onmouseout="highlight(null)">GPUs</button>
<button class="btn default" onclick="exp()">EXPAND</button>
<button class="btn default" onclick="col()">COLLAPSE</button>
<button class="btn default" onclick="gbt()">GBT</button>
<button class="btn default" onclick="digi()">Digilab</button>
<button class="btn default" onclick="home()">Home</button>
<script>
onmouseout="highlight(null)"
	
var margin = {top: 20, right: 120, bottom: 20, left: 100},
	width = 1260 - margin.right - margin.left,
	height = 1200 - margin.top - margin.bottom;

// ************** Generate the tree diagram	 *****************var nic = "rgba(85, 98, 112, 1)";
var nic = "rgba(85, 98, 112, 1)";
var cpu = "rgba(78, 205, 196, 1)";
var disk = "rgba(141, 225, 88, 1)";
var mem = "rgba(196, 77, 88, 1)";
var gpu = "rgba(245, 149, 120, 1)";
var i = 0,
	duration = 750,
	root;

var tree = d3.layout.tree()
	.size([height, width]);

var diagonal = d3.svg.diagonal()
	.projection(function(d) { return [d.y, d.x]; });

  //var container = html[<svg></svg>';

  
var svg = d3.select("body").append("svg")
	.attr("width", width + margin.right + margin.left)
	.attr("height", height + margin.top + margin.bottom)
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");


d3.json("tree_data.json", function(error, flare) {
  if (error) throw error;

  root = flare;
  root.x0 = height / 2;
  root.y0 = 0;
  d3.saveRoot = root
  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);
  update(root);
});

function expand(d){   
    var children = (d.children)?d.children:d._children;
    if (d._children ) { 
           
        d.children = d._children;
        d._children = null; 
        
    }
    if(children)
   	  children.forEach(expand);
}
function exp(){
	expand1(root);
	update(root) 
}
function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }
  function col(){
	collapse(root);
	update(root) 
}
function gbt(){
  	root = d3.saveRoot;
  	root = root.children[0]
  	update(root)
  }
 function digi(){
 	root = d3.saveRoot;
  	root = root.children[1];
  	update(root)
  }
 function home(){
 	root = d3.saveRoot
 	update(root)
 }
function get_color(d){
	
	switch(d.type) {
	    case 'nic':
	        return nic;
	    case 'cpu':
	        return cpu;
	    case 'disk':
	        return disk;
	    case 'mem':
	        return mem;
	    case 'gpu':
	        return gpu;
	    default:
	    	return "#fff"
	}
	
}
function get_stroke(d){
	
	switch(d.name) {
	    case 'NICs':
	        return nic;
	    case 'CPUs':
	        return cpu;
	    case 'Disks':
	        return disk;
	    case 'Memory':
	        return 'purple';
	    case 'GPUs':
	        return gpu;
	    default:
	    if(d.children || d._children ){
	    	return "lightgrey";
	    }else{
	    	return "#fff"
	    }
	}
	
}
var to_display = ["name", "model", "serial", "speed", "make", "diskID", "amount", "ip", "clock", "cores"];


function find_tt_data(x){
	//console.log(typeof(d) === 'object')
	var values = d3.values(x)
	var m2 = d3.map(x, (function(d){
		return  typeof(d) === 'string'? d :"" ;
	}))
	console.log(m2.values())

	return values;
}
const getDepth = ({ children }) => 1 +
    (children ? Math.max(...children.map(getDepth)) : 0)

function update(source) {
	 var newHeight = Math.max(tree.nodes(root).reverse().length * 20, height);
	//console.log(getDepth(root))
	var newWidth = Math.max(getDepth(root)*300, width)
	
  d3.select("body svg")
    .attr("width", newWidth + margin.right + margin.left)
    .attr("height", newHeight + margin.top + margin.bottom);

  tree = d3.layout.tree().size([newHeight, newWidth]);

  var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);


  // Compute the new tree layout/.
  //var nodes = tree.nodes(root).reverse(),
//	  links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 200; });
  

  // Update the nodes…
  var node = svg.selectAll("g.node")
	  .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
	  .attr("class", function(d) { return "node " + d.type; })
	  .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
	  .on("click", click)
	  .on("dblclick", dblClick)
	  .on("mouseover", function(d) {
        if (d.tt_info){
        	div.transition()
          //.duration(500)
          .delay(1000)
          .style("opacity", .9);
        div.html(d.tt_info.join("\r\n"))/////////////////////////////////////////////////////////////////////////////////////////////////////////

          .style("left", d.y+ 90 + "px")
          .style("top", d.x  + 10+ "px");
        }})
      .on("mouseout", function(d) {
        div.transition()
          .duration(100)
          .style("opacity", 0);
        });
   

  nodeEnter.append("circle")
	 // .attr("r", 5)
    .attr("r", 10)
	  .style("fill", function(d)  { return d._children ? get_stroke(d) : '#fff'; });

  nodeEnter.append("text")
	  .attr("x", function(d) { return d.children || d._children ? - (30 - (d.depth*2))  : (30 - (d.depth*2)); })
	  .attr("dy", ".35em")
	  .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
	  .text(function(d) { return d.name ? d.name : d.hostname ; })
	  .style("fill-opacity", 1e-6);


  var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);
  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
    .attr("r", function(d) { return (5 - (d.depth/2)) * 5 })
	 // .attr("r", 10)
	 //.attr('class', function(d) { return d.type;});
	  .style("fill", function(d) { return d._children ? get_stroke(d) : get_color(d); })
	  .style("stroke",function(d) { return get_stroke(d) });
 // nodeUpdate.select("circle")
  //	.attr('class', function(d) { return ""+d.type;});

  nodeUpdate.select("text")
  	.attr("class", "noselect")
	  .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
	  .remove();

  nodeExit.select("circle")
	  .attr("r", 1e-6);

  nodeExit.select("text")
	  .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
	  .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
	  .attr("class", "link")

    //.style("stroke-width", findStroke())// == 1 ? 0 : d.target.depth * 5; })
	  .attr("d", function(d) {
		var o = {x: source.x0, y: source.y0};
		return diagonal({source: o, target: o});
	  })
	  .style("stroke-width", function(d) { 
	  console.log(d.target.r)
	  	if(d.target.stroke < ((5 - (d.target.depth/2)) * 10)){
	  		return d.target.stroke ; 
	  	}
	  	return ((5 - (d.target.depth/2)) * 10) ; })
	  .style("stroke", function(d) { 
	 
	  	if(d.target.stroke >1 ){
	  		return "green"; 
	  	}
	  	return "#ccc";})
	  .style("opacity", function(d) { 
	 
	  	if(d.target.stroke >1 ){
	  		return ".5"; 
	  	}
	  	return "1";});
//	  .style("stroke-width", d.stroke);
//	  .style("stroke-width", d.stroke);

  // Transition links to their new position.
  link.transition()
	  .duration(duration)
	  .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
	  .duration(duration)
	  .attr("d", function(d) {
		var o = {x: source.x, y: source.y};
		return diagonal({source: o, target: o});
	  })
	  .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
	d.x0 = d.x;
	d.y0 = d.y;
  });


}

//============================================================================================




function highlight(type) {
  if (type == null) d3.selectAll(".node").classed("active", false);
  else d3.selectAll(".node." + type).classed("active", true);
}
// Toggle children on click.
function click(d) {
	console.log(d)
  if (d.children) {
	d._children = d.children;
	d.children = null;
  } else {
	d.children = d._children;
	d._children = null;
  }
  update(d);
}
function dblClick(d) {
	console.log("doubleclick", d.children_hardware);
	
	temp = d.children_hardware;
	d.children_hardware = d.children;
	d.children = temp;
	
	tempx = d.x
	click(d);
	d.x0 = tempx
	click(d);
  	d.children.forEach(collapse);
  
  update(d);
    
    
}
function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
}

</script>



